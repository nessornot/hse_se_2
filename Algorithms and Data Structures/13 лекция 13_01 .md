# Хеширование


## Содержание

- хеширование-1
- хеш-функции и их свойства


## Формула оценки

0.45 \* НАКОП + 0.2 \* ПР + 0.35 \* ЭКЗ

$$
\text{НАКОП = } \text{min}\left( \frac{RP + BP}{RP_{max}}{ \ * \ 10; \ 10} \right )
$$
RP - сумма баллов за ДЗ, тесты и КР
BP - сумма баллов за бонусные задания
ПР - активность на семинарах

### Условия автомата

- НАКОП >= 8 (75%)
- ПР >= 8
- ДЗ и КР >= 70%

## Хеширование-1

Хеширование - процесс отображения объекта на целое число в диапазоне \[0..M-1\]. 
Коллизия - совпадение хеша у разных объектов.

Хеш-таблицы используют хеш-функцию вместе с некоторым механизмом обработки коллизий.

![[Pasted image 20250114181436.png]]
<br>
### Объект в 32-битное число (хеширование)

Процесс преобразования объекта в 32-битное целое число называется **хешированием**.
- Быстрый процесс Θ(1)
- Детерминированный процесс (предсказуемый)
- Если **x = y**, тогда **hash(x) = hash(y)**
- Низкая вероятность совпадения значений на разный объектах

#### Хеширование рациональных чисел (пример)

```cpp
class Rational {
private:
	int numer, denom;
public:
	Rational(int, int);
	size_t hash();
};

Rational::Rational(int a, int b) : numer(a), denom(b) {
	int divisor = gcd(numer, denom);
	divisor = (denom >= 0) ? divisor : -divisor;
	
	numer /= divisor;
	denom /= divisor;
}

size_t Rational::hash() const {
	return static_cast<size_t>(numer) + 4'294'967'296 * static_cast<size_t>(denom);
}
```

### 32-битное число в индекс (MAPPING DOWN)

Процесс преобразования 32-битного числа в индекс - `hash_M(key)`
- Взятие остатка - операция mod
- Мультипликативный метод
- Метод середины квадрата - псевдослучайные значения

#### Простейший способ - mod

```cpp
size_t hash_M(size_t key, size_t M){
	return key % M;
}
```

Деление - дорогая операция, в случае если M = 2^m мы можем использовать побитовые операции, чтобы упростить расчеты.

##### Применение побитовых операций при M = 2^m 

- Извлечение **n** младших битов в двоичном числе можно выполнить с помощью побитого И (`&`)

![[Pasted image 20250114191946.png]]

- Умножение A_p на p^n соответствует приписыванию **n** нулей справа к A_p
	- Умножение - побитовый сдвиг **влево**
	- Деление - побитовый сдвиг **вправо**

![[Pasted image 20250114192503.png]]

#### Простейший способ с побитовыми сдвигами

```cpp
size_t hash(size_t key, size_t M) {
	return key & ((1 << m) - 1);
}
```

Mapping down с использованием **mod** полностью определяется младшими разрядами ключа.

#### Мультипликативный метод

Будем извлекать **m** средних битов в числе **C \* key** 

```cpp
const size_t C = 581869333; // Какое-то число

size_t hash(size_t key, size_t m) {
	size_t shift = (32 - m) / 2;
	return ((C * key) >> shift & ((1 << m) - 1));
}
```

Пусть m = 10, key = 42, тогда после выполнения функции получим индекс, вписывающийся в 2^m

![[Pasted image 20250114201138.png]]

При мультипликативном методе MAPPING DOWN в формировании итогового индекса участвуют **все разряды** ключа.

## Универсальное семейство

Формально:
$$
\text{Пусть H - это такое семейство хеш-функций, где:}
$$
$$
\forall x,y \in U, \ \ x\neq y
$$
$$
|\{h \in H:h(x) = h(y)\}| = \frac{|H|}{M}
$$
$$
\Rightarrow \text{Вероятность коллизии } \ \forall \ h \in H \ \ \text{составляет } \frac{1}{M}
$$
Другими словами:
Вероятность того, что случайная функция h из H сопоставит два **разных** элемента x и y **в один** и тот же хеш (коллизия), ограничена сверху величиной 1/M.

Идеальное хеширование **полностью исключает** возникшие коллизии.