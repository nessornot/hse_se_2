
# Принципы проектирования

<br>

## Взаимодействие между классами

### Наследование

По возможности наследование использовать не нужно.

### Ассоциация

```cs
class Team
{
	
}

class Player
{
	public Team Team { get; set; }
}
```

Если хочется использовать наследование, то нужно подумать, может быть в этой ситуации подойдет ассоциация.

Между доменными объектами чаще всего используется ассоциация.
### Композиция

Как бы контролирует время жизни используемых в классе объектов. 
Композиция используется в момент проектирования. В остальном почти не используется. 

```cs
public class ElectricEngine
{}

public class Car
{
	ElectricEngine engine;
	public Car()
	{
		engine = new ElectricEngine();
	}
}
```

<br>

### Агрегация

```cs
public abstract class Engine
{}

public class Car
{
	Engine engine;
	public Car(Engine eng)
	{
		engine = eng;
	}
}
```

#### Разница между композицией и агрегацией:

Композиция не спрашивает, она создает что-то в конструкторе сама.
Агрегация дает право выбрать, какой именно объект нужно использовать в конструкторе.

### Реализация

```cs
public interface IMovable
{
	void Move();
}

public class Car : IMovable
{
	public void Move()
	{
		Console.WriteLine("Машина едет");
	}
}
```

Интерфейсы принято делать небольшими, а базовые классы нет.

## Когда следует использовать 

### Абстрактные классы:
- Определить общий функционал для родственных объектов
- Проектируем большую функциональную единицу, которая содержит много базового функционала

### Интерфейсы:
- Если нам надо определить функционал для группы разрозненных объектов, которые могут быть никак не связаны между собой
- Если мы проектируем небольшой функциональный тип

Если классы относятся к единой системе классификации, то выбирается абстрактный класс. Иначе выбирается интерфейс.

## Уровни абстракции

### Первый слой
В игре есть один класс трансформера, все свойства и поведение описаны в нем.
### Второй уровень
В игре есть базовый трансформер с основными способностями и классы трансформеров  
со своей специализацией. Тем самым игроку предоставляется возможность выбора, а разработчикам упрощается добавление новых классов.
### Третий уровень
Помимо классификации трансформеров вводится агрегация с помощью системы слотов и компонентов. Теперь часть поведения будет определяться тем, какой стаф игрок установил в своего трансформера.

### Четвертый уровень
В компоненты можно тоже включить собственную агрегацию, предоставляющую возможность выбора материалов и деталей, из которого собираются эти компоненты.

## Выбор уровня абстракции

1. Абстракции недостаточно. Расширения проекта будут упираться в архитектурные ограничения.
2. Уровень абстракции слишком высок. Оверинжиниринг в вид сложной архитектуры, которую трудно поддерживать, и излишней гибкости, которая никогда в этом проекте не пригодится.

Любую архитектурную проблему можно решить через добавление уровня абстракции, кроме проблемы большого количества абстракций.

## Принципы дизайна

Принцип проектирования - методологическое правило, которое выражает общий взгляд на разработку ПО.

## SOLID

Вообще правильнее SLIDO, т.к. принцип O вытекает из остальных.

<br>

## Single Responsibility Principle - Принцип единственной ответственности

Класс должен иметь только одну причину для изменения.
С классом должен работать только один Actor(?). 

Actor(?) - тот, кто использует ваш класс.

![[Pasted image 20250118101615.png]]

```cs

// Этот класс можно разделить на 2 отдельных, чтобы впоследствии поддерживать код было легче.

class Report
{
	// part 1
	public string Text { get; set; }
	public void GoToFirstPage()...
	public void GoToLastPage()...
	public void GoToPage()...

	// part 2
	public void Print()...
	public void PrintToPDF()...
	public void PrintToPrinter()...
}
```

Сущности должны отвечать за одну область задач.
## Liskov substitution principle - Принцип подстановки Барбары Лисков

Вы должны иметь возможность использовать производный класс вместо родительского класса и вести себя с ним таким же образом без внесения изменений.

```cs
// Базовый класс прямоугольника
class Rectangle
{
	public virtual Width { get; set; }
	public virtual Height { get; set; }

	public int GetArea()
	{
		return Width * Height;
	}
}

// Производный класс квадрата
class Square : Rectangle 
{
	public override int Width
	{
		get { return base.Width; }
		set 
		{  
			base.Width = value;
			base.Height = value;
		}
	}
	
	public override Height... // то же самое
}
```

При использовании производного класса в качестве базового возникает ошибка, в примере ниже мы не можем корректно задавать базовые поля квадрату, т.к. они у него должны быть равны, из-за чего происходит неверное вычисление.

```cs
class Program
{
	static void Main(string[] args)
	{
		Rectangle rect = new Square();
		TestRectangleArea(rect);
		
		Console.Read();
	}
	
	public static void TestRectangleArea(Rectangle rect)
	{
		rect.Height = 5;
		rect.Width = 10;
		if (rect.GetArea() != 50)
		{
			throw new Exception("Incorrect area!");
		}
	}
}
```

Проблема решается через проверку типа объекта:
```cs
public static void TestRectangleArea(Rectangle rect)
{
	if (rect is Square)
	{
		rect.Height = 5;
		if (rect.GetArea() != 25)
			throw new Exception("Incorrect area!");
	}
	
	else if (rect is Rectangle)
	{
		rect.Height = 5;
		rect.Width = 10;
		if (rect.GetArea() != 50)
			throw new Exception("Incorrect area!");
	}
}
```

Контракт с ребенком должен уменьшать требования к входным данным, а не увеличивать.
## Interface segregation principle - Принцип разделения интерфейсов

Слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе

## Dependency inversion principle - Инверсия зависимостей

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Класс высокого уровня - тот который ближе к контроллеру/человеку.

DIP - теперь книга не зависит от реализаций
DI - то, каким образом зависимые объекты будут внедряться в основной 
IOC - Инверсия управления. 

IOC и DIP взаимосвязаны: DIP практически невозможно реализовать без IoC, но не наоборот. При этом использование IoC не гарантирует соблюдение DIP.

## Open-Closed Principle - Принцип открытости/закрытости

Класс должен быть открыт для расширения, но закрыт для изменений.

Мы не хотим чтобы объект постоянно переписывался, вместо этого нужно организовать возможность имплементировать разные реализации.

![[Pasted image 20250118164303.png]]

На след. лекции будет разбираться GRASP и др.















